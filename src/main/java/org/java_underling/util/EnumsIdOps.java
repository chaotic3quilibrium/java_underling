package org.java_underling.util;


import org.java_underling.lang.ClassesOps;
import org.java_underling.lang.ParametersValidationException;
import org.jetbrains.annotations.NotNull;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.util.Map.Entry;
import static java.util.Map.entry;

/**
 * An {@link EnumsIdOps} is a thread-safe immutable non-{@code null} utility class that produces a system-wide singleton
 * for augmenting an {@link Enum}'s mutable {@code values()} array by wrapping it in an unmodifiable {@link List}, and
 * providing an associated ID for each enum value.
 * <p>
 * A precondition for using the {@link EnumsIdOps} factory methods is:
 * <ul>
 *   <li>For all the String search terms generated by the factory for a specific {@link Enum}, the terms must be unique after being shifted to lower case. If this precondition fails, the factory will throw an {@link ParametersValidationException} detailing each of the search term collisions.</li>
 * </ul>
 * <p>
 * It also produces an internal cache for enabling a fast O(1) case-insensitive name search for a specific {@link Enum}
 * or ID value (as opposed to the slower O(n) common pattern scanning through the mutable {@code values()} array). In
 * addition, an alternate String may also be associated to each enum value to ease decoding from external sources.
 * <p>
 * The {@link EnumsIdOps} class may be added as a property directly to a newly defined {@link Enum}. And/or, it can be
 * used to wrap a pre-existing {@link Enum} which is unable to be directly enhanced/modified (for example, it is part of
 * a vendor SDK).
 * <p>
 * Both approaches, embedded or wrapping, provide all the same functionality, augmentation, and enhancement. And because
 * it is a system-wide singleton, implementing both will result in the exact same instance being returned for both
 * regardless of context.
 * <p>
 *
 * @param <E>  type of the {@link Enum}
 * @param <ID> type of the associated {@code ID}
 */
public final class EnumsIdOps<E extends Enum<E>, ID> {
  private static final Object ENUM_ID_OPS_BY_CLASS_E_SYNC = new Object();
  private static final Object EXTENDED_CONTEXT_BY_CLASS_E_LOCK = new Object();
  private static final Map<Class<?>, ExtendedContext<?, ?>> EXTENDED_CONTEXT_BY_CLASS_E = new ConcurrentHashMap<>();
  private static volatile Memoizer<Class<?>, EnumsIdOps<?, ?>> ENUM_ID_OPS_BY_CLASS_E;

  /**
   * Returns an {@link EnumsIdOps} <i>singleton</i> for the provided {@link Enum}'s class using {@link Enum#ordinal()}
   * for the associated {@code ID}.
   * <p>
   * Rather than reproduce the implementation, a property is used to delegate to {@link EnumsOps} much of the basic
   * {@link Enum} behaviors. This implementation references and reuses the {@link EnumsOps} singleton to augment with
   * the {@code ID} associations.
   * <p>
   * Due to use of a thread-safe internal cache, upon the first call to this factory method with a specific {@link Enum}
   * class, an instance of {@link EnumsIdOps} will be generated stored within the internal cache. All future calls to
   * this factory method specifying the same {@link Enum} class (at least within the same {@link ClassLoader}) will
   * ensure the same {@link EnumsIdOps} instance is returned. There are no means provided to allow additional
   * independent instances of {@link EnumsIdOps} for the same {@link Enum} class.
   *
   * @param classE the {@link Class} of the specific enum being augmented
   * @param <E>    the specific Enum's type
   * @return an {@link EnumsIdOps} <i>singleton</i> for the provided {@link Enum}'s class
   */
  @NotNull
  public static <E extends Enum<E>> EnumsIdOps<E, Integer> from(
      @NotNull Class<E> classE
  ) {
    return from(classE, 0);
  }

  /**
   * Returns an {@link EnumsIdOps} <i>singleton</i> for the provided {@link Enum}'s class using {@link Enum#ordinal()}
   * plus an offset for the associated {@code ID}.
   * <p>
   * Rather than reproduce the implementation, a property is used to delegate to {@link EnumsOps} much of the basic
   * {@link Enum} behaviors. This implementation references and reuses the {@link EnumsOps} singleton to augment with
   * the {@code ID} associations.
   * <p>
   * Due to use of a thread-safe internal cache, upon the first call to this factory method with a specific {@link Enum}
   * class, an instance of {@link EnumsIdOps} will be generated stored within the internal cache. All future calls to
   * this factory method specifying the same {@link Enum} class (at least within the same {@link ClassLoader}) will
   * ensure the same {@link EnumsIdOps} instance is returned. There are no means provided to allow additional
   * independent instances of {@link EnumsIdOps} for the same {@link Enum} class.
   *
   * @param classE        the {@link Class} of the specific enum being augmented
   * @param ordinalOffset the amount to add to each {@link Enum} value's ordinal before associating the numeric value as
   *                      an {@code ID}
   * @param <E>           the specific Enum's type
   * @return an {@link EnumsIdOps} <i>singleton</i> for the provided {@link Enum}'s class
   */
  @NotNull
  public static <E extends Enum<E>> EnumsIdOps<E, Integer> from(
      @NotNull Class<E> classE,
      int ordinalOffset
  ) {
    return from(
        classE,
        enumValue ->
            enumValue.ordinal() + ordinalOffset);
  }

  /**
   * Returns an {@link EnumsIdOps} <i>singleton</i> for the provided {@link Enum}'s class using {@code fEToId} to derive
   * the associated {@code ID} from each {@link Enum} value, and using the {@link Object#toString()} method on the
   * {@code ID} to derive the String search term for each {@code ID}.
   * <p>
   * A precondition for using the EnumsIdOps factory methods is:
   * <ul>
   *   <li>For all the String search terms generated by the factory for a specific {@link Enum}, the terms must be unique after being shifted to lower case. If this precondition fails, the factory will throw an {@link ParametersValidationException} detailing each of the search term collisions.</li>
   * </ul>
   * <p>
   * Rather than reproduce the implementation, a property is used to delegate to {@link EnumsOps} much of the basic
   * {@link Enum} behaviors. This implementation references and reuses the {@link EnumsOps} singleton to augment with
   * the {@code ID} associations.
   * <p>
   * Due to use of a thread-safe internal cache, upon the first call to this factory method with a specific {@link Enum}
   * class, an instance of {@link EnumsIdOps} will be generated stored within the internal cache. All future calls to
   * this factory method specifying the same {@link Enum} class (at least within the same {@link ClassLoader}) will
   * ensure the same {@link EnumsIdOps} instance is returned. There are no means provided to allow additional
   * independent instances of {@link EnumsIdOps} for the same {@link Enum} class.
   *
   * @param classE the {@link Class} of the specific enum being augmented
   * @param fEToId a function to produce an {@code ID} value from an {@link Enum} value
   * @param <E>    the specific Enum's type
   * @return an {@link EnumsIdOps} <i>singleton</i> for the provided {@link Enum}'s class using {@code fEToId} to derive
   *     the associated {@code ID} from each {@link Enum} value, using {@code fIdToString} to derive the String search
   *     term for each {@code ID}, and expanding the String search using {@code fEToAltString} to derive an alternative
   *     String from an {@link Enum} value
   */
  @NotNull
  public static <E extends Enum<E>, ID> EnumsIdOps<E, ID> from(
      @NotNull Class<E> classE,
      @NotNull Function<E, ID> fEToId
  ) {
    return from(
        classE,
        fEToId,
        Object::toString);
  }

  /**
   * Returns an {@link EnumsIdOps} <i>singleton</i> for the provided {@link Enum}'s class using {@code fEToId} to derive
   * the associated {@code ID} from each {@link Enum} value, and using {@code fIdToString} to derive the String search
   * term for each {@code ID}.
   * <p>
   * A precondition for using the EnumsIdOps factory methods is:
   * <ul>
   *   <li>For all the String search terms generated by the factory for a specific {@link Enum}, the terms must be unique after being shifted to lower case. If this precondition fails, the factory will throw an {@link ParametersValidationException} detailing each of the search term collisions.</li>
   * </ul>
   * <p>
   * Rather than reproduce the implementation, a property is used to delegate to {@link EnumsOps} much of the basic
   * {@link Enum} behaviors. This implementation references and reuses the {@link EnumsOps} singleton to augment with
   * the {@code ID} associations.
   * <p>
   * Due to use of a thread-safe internal cache, upon the first call to this factory method with a specific {@link Enum}
   * class, an instance of {@link EnumsIdOps} will be generated stored within the internal cache. All future calls to
   * this factory method specifying the same {@link Enum} class (at least within the same {@link ClassLoader}) will
   * ensure the same {@link EnumsIdOps} instance is returned. There are no means provided to allow additional
   * independent instances of {@link EnumsIdOps} for the same {@link Enum} class.
   *
   * @param classE      the {@link Class} of the specific enum being augmented
   * @param fEToId      a function to produce an {@code ID} value from an {@link Enum} value
   * @param fIdToString a function to produce a String value for an ID, assuming the returned values is different from
   *                    that returned by the .toString() method
   * @param <E>         the specific Enum's type
   * @return an {@link EnumsIdOps} <i>singleton</i> for the provided {@link Enum}'s class using {@code fEToId} to derive
   *     the associated {@code ID} from each {@link Enum} value, and using {@code fIdToString} to derive the String
   *     search term for each {@code ID}
   */
  @NotNull
  public static <E extends Enum<E>, ID> EnumsIdOps<E, ID> from(
      @NotNull Class<E> classE,
      @NotNull Function<E, ID> fEToId,
      @NotNull Function<ID, String> fIdToString
  ) {
    return fromHelper(
        classE,
        fEToId,
        fIdToString,
        Optional.empty());
  }

  /**
   * Returns an {@link EnumsIdOps} <i>singleton</i> for the provided {@link Enum}'s class using {@code fEToId} to derive
   * the associated {@code ID} from each {@link Enum} value, using {@code fIdToString} to derive the String search term
   * for each {@code ID}, and expanding the String search using {@code fEToAltString} to derive an alternative String
   * from an {@link Enum} value.
   * <p>
   * A precondition for using the EnumsIdOps factory methods is:
   * <ul>
   *   <li>For all the String search terms generated by the factory for a specific {@link Enum}, the terms must be unique after being shifted to lower case. If this precondition fails, the factory will throw an {@link ParametersValidationException} detailing each of the search term collisions.</li>
   * </ul>
   * <p>
   * Rather than reproduce the implementation, a property is used to delegate to {@link EnumsOps} much of the basic
   * {@link Enum} behaviors. This implementation references and reuses the {@link EnumsOps} singleton to augment with
   * the {@code ID} associations.
   * <p>
   * Due to use of a thread-safe internal cache, upon the first call to this factory method with a specific {@link Enum}
   * class, an instance of {@link EnumsIdOps} will be generated stored within the internal cache. All future calls to
   * this factory method specifying the same {@link Enum} class (at least within the same {@link ClassLoader}) will
   * ensure the same {@link EnumsIdOps} instance is returned. There are no means provided to allow additional
   * independent instances of {@link EnumsIdOps} for the same {@link Enum} class.
   *
   * @param classE        the {@link Class} of the specific enum being augmented
   * @param fEToId        a function to produce an {@code ID} value from an {@link Enum} value
   * @param fIdToString   a function to produce a String value for an ID, assuming the returned values is different from
   *                      that returned by the .toString() method
   * @param fEToAltString a function to produce an alternative String value for an Enum value
   * @param <E>           the specific Enum's type
   * @return an {@link EnumsIdOps} <i>singleton</i> for the provided {@link Enum}'s class using {@code fEToId} to derive
   *     the associated {@code ID} from each {@link Enum} value, using {@code fIdToString} to derive the String search
   *     term for each {@code ID}, and expanding the String search using {@code fEToAltString} to derive an alternative
   *     String from an {@link Enum} value
   */
  @NotNull
  public static <E extends Enum<E>, ID> EnumsIdOps<E, ID> from(
      @NotNull Class<E> classE,
      @NotNull Function<E, ID> fEToId,
      @NotNull Function<ID, String> fIdToString,
      @NotNull Function<E, String> fEToAltString
  ) {
    return fromHelper(
        classE,
        fEToId,
        fIdToString,
        Optional.of(fEToAltString));
  }

  private record ExtendedContext<E extends Enum<E>, ID>(
      @NotNull Function<E, ID> fEToId,
      @NotNull Function<ID, String> fIdToString,
      @NotNull Optional<Function<E, String>> optionalFEToAltString
  ) {

  }

  @SuppressWarnings("OptionalUsedAsFieldOrParameterType")
  @NotNull
  private static <E extends Enum<E>, ID> EnumsIdOps<E, ID> fromHelper(
      @NotNull Class<E> classE,
      @NotNull Function<E, ID> fEToId,
      @NotNull Function<ID, String> fIdToString,
      @NotNull Optional<Function<E, String>> optionalFEToAltString
  ) {
    if (ENUM_ID_OPS_BY_CLASS_E == null) {
      synchronized (ENUM_ID_OPS_BY_CLASS_E_SYNC) {
        if (ENUM_ID_OPS_BY_CLASS_E == null) {
          //noinspection unchecked
          ENUM_ID_OPS_BY_CLASS_E = Memoizer.from(classWildcard ->
              ClassesOps.narrow(() ->
                      (Class<E>) classWildcard)
                  .map(classWildCardNarrowedToClassE ->
                      Optional.ofNullable(EXTENDED_CONTEXT_BY_CLASS_E.get(classWildCardNarrowedToClassE))
                          .map(extendedContextWildcardWildcard ->
                              ClassesOps.narrow(() ->
                                      (ExtendedContext<E, ID>) extendedContextWildcardWildcard)
                                  .map(extendedContextWildcardWildcardNarrowedToExtendedContextEAndID ->
                                      new EnumsIdOps<>(
                                          classWildCardNarrowedToClassE,
                                          extendedContextWildcardWildcardNarrowedToExtendedContextEAndID.fEToId,
                                          extendedContextWildcardWildcardNarrowedToExtendedContextEAndID.fIdToString,
                                          extendedContextWildcardWildcardNarrowedToExtendedContextEAndID.optionalFEToAltString))
                                  .orElseThrow(() ->
                                      new IllegalStateException("unable to narrow to ExtendedContext<E, ID> for class " + extendedContextWildcardWildcard.getClass().getName())))
                          .orElseThrow(() ->
                              new IllegalStateException("unable to obtain extended context for class " + classWildCardNarrowedToClassE.getName())))
                  .orElseThrow(() ->
                      new IllegalStateException("unable to narrow to Class<E> to for class " + classWildcard.getName())));
        }
      }
    }

    synchronized (EXTENDED_CONTEXT_BY_CLASS_E_LOCK) {
      EXTENDED_CONTEXT_BY_CLASS_E.put(classE, new ExtendedContext<>(fEToId, fIdToString, optionalFEToAltString));
      try {
        //noinspection unchecked
        return ClassesOps.narrow(() ->
                (EnumsIdOps<E, ID>) ENUM_ID_OPS_BY_CLASS_E.get(classE))
            .orElseThrow(() ->
                new IllegalStateException("unable to narrow to EnumsIdOps<E, ID> for class " + classE.getName()));
      } finally {
        EXTENDED_CONTEXT_BY_CLASS_E.remove(classE);
      }
    }
  }

  private final EnumsOps<E> enumsOps;
  private final Class<ID> classId;
  private final Map<E, ID> orderedMapIdByEnumValue;
  private final Map<ID, E> orderedMapEnumValueById;
  private final Map<String, E> enumValueByNameOrIdOrAltToStringLowerCase;

  private enum CollisionSource {
    ENUM_VALUE,
    ID_VALUE,
    ALT_STRING_VALUE
  }

  @SuppressWarnings("OptionalUsedAsFieldOrParameterType")
  private EnumsIdOps(
      @NotNull Class<E> classE,
      @NotNull Function<E, ID> fEToId,
      @NotNull Function<ID, String> fIdToString,
      @NotNull Optional<Function<E, String>> optionalFEToAltString
  ) {
    var enumOps = EnumsOps.from(classE);
    var enumsValues = enumOps.toList();
    var orderedMapIdByEnumValue = MapsOps.toMapOrderedUnmodifiable(
        enumsValues.stream(),
        (e) ->
            Optional.of(entry(e, fEToId.apply(e))));
    //validate the .toLowerCase() of...
    //  - enumValue.toString()
    //  - fIdToString.apply(fEToId.apply(enumValue))
    //  - optionalFEToAltString.map(fEToAltString -> fEToAltString.apply(enumValue)).get()
    //  ...are distinct as all 3 valueOf* methods depend upon this assumption.
    var nameLowerCaseAndEnumValue = enumsValues
        .stream()
        .map(enumValue ->
            entry(
                enumValue.name().toLowerCase(),
                entry(enumValue, CollisionSource.ENUM_VALUE)))
        .toList();
    var idToStringLowerCasesAndEnumValue = orderedMapIdByEnumValue
        .entrySet()
        .stream()
        .map(enumValueAndId ->
            entry(
                fIdToString.apply(enumValueAndId.getValue()).toLowerCase(),
                entry(enumValueAndId.getKey(), CollisionSource.ID_VALUE)))
        .toList();
    var altStringLowerCasesAndEnumValue = optionalFEToAltString
        .map(fEToAltString ->
            enumsValues
                .stream()
                .map(enumValue ->
                    entry(
                        fEToAltString.apply(enumValue).toLowerCase(),
                        entry(enumValue, CollisionSource.ALT_STRING_VALUE)))
                .toList())
        .orElse(List.of());
    var keyLowerCaseAndEnumValueAndCollisionSources =
        Stream.of(
                nameLowerCaseAndEnumValue.stream(),
                idToStringLowerCasesAndEnumValue.stream(),
                altStringLowerCasesAndEnumValue.stream())
            .flatMap(Function.identity())
            .collect(Collectors.groupingBy(Entry::getKey))
            .values()
            .stream()
            .filter(eAsStrings ->
                eAsStrings.size() > 1)
            .flatMap(Collection::stream)
            .toList();
    if (!keyLowerCaseAndEnumValueAndCollisionSources.isEmpty()) {
      throw new ParametersValidationException(
          "EnumsIdOps invalid parameter(s)",
          "invalid state for enum [%s] where the .toLowerCase() of enumValue.toString(), fIdToString.apply(fEToId.apply(enumValue)), and optionalFEToAltString.map(fEToAltString -> fEToAltString.apply(enumValue)).get() is not unique across all the enums values - erred values: %s".formatted(
              classE.getSimpleName(),
              String.join(
                  EnumsOps.DEFAULT_SEPARATOR,
                  keyLowerCaseAndEnumValueAndCollisionSources
                      .stream()
                      .sorted(
                          Comparator.<Entry<String, Entry<E, CollisionSource>>, Integer>comparing(
                                  entry ->
                                      entry.getValue().getKey().ordinal())
                              .thenComparing(Entry::getKey))
                      .map(keyLowerCaseAndEnumValueAndCollisionSource -> {
                        var keyLowerCase = keyLowerCaseAndEnumValueAndCollisionSource.getKey();
                        var enumValue = keyLowerCaseAndEnumValueAndCollisionSource.getValue().getKey();
                        var collisionSource = keyLowerCaseAndEnumValueAndCollisionSource.getValue().getValue();

                        return "keyLowerCase: %s -> enumValueName: %s -> collisionSource: %s".formatted(
                            keyLowerCase,
                            enumValue.name(),
                            collisionSource.name());
                      })
                      .toList())));
    }
    var classWildcard = orderedMapIdByEnumValue.values().iterator().next().getClass();
    //noinspection unchecked
    var classId = ClassesOps.narrow(() ->
            (Class<ID>) classWildcard)
        .orElseThrow(() ->
            new IllegalStateException("unable to narrow to Class<ID> for class " + classWildcard.getName()));
    //all preconditions have been validated, so assign the instance fields
    this.enumsOps = enumOps;
    this.classId = classId;
    this.orderedMapIdByEnumValue = orderedMapIdByEnumValue;
    this.orderedMapEnumValueById = MapsOps.swapOrdered(orderedMapIdByEnumValue);
    this.enumValueByNameOrIdOrAltToStringLowerCase = Stream.of(
            nameLowerCaseAndEnumValue.stream(),
            idToStringLowerCasesAndEnumValue.stream(),
            altStringLowerCasesAndEnumValue.stream())
        .flatMap(Function.identity())
        .map(keyLowerCaseAndEnumValueAndCollisionSource ->
            entry(
                keyLowerCaseAndEnumValueAndCollisionSource.getKey(),
                keyLowerCaseAndEnumValueAndCollisionSource.getValue().getKey()))
        .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
  }

  /**
   * Returns an {@link EnumsOps} <i>singleton</i> for the provided {@link Enum}'s class used to delegate base
   * behaviors.
   *
   * @return an {@link EnumsOps} <i>singleton</i> for the provided {@link Enum}'s class used to delegate base behaviors
   */
  @NotNull
  public EnumsOps<E> getEnumsOps() {
    return this.enumsOps;
  }

  /**
   * Returns the {@link Class} of the id being associated with the enum.
   *
   * @return the {@link Class} of the id being associated with the enum
   */
  @NotNull
  public Class<ID> getClassId() {
    return this.classId;
  }

  /**
   * Returns an unmodifiable {@link List} of each of the {@link Enum}s with its associated ID.
   *
   * @return an unmodifiable {@link List} of each of the {@link Enum}s with its associated ID
   */
  @NotNull
  public List<Entry<E, ID>> toList() {
    return getOrderedMapIdByEnumValue()
        .entrySet()
        .stream()
        .toList();
  }

  /**
   * Returns a {@link Stream} of each of the {@link Enum}s with its associated {@code ID}.
   *
   * @return a {@link Stream} of each of the {@link Enum}s with its associated {@code ID}
   */
  @NotNull
  public Stream<Entry<E, ID>> stream() {
    return getOrderedMapIdByEnumValue()
        .entrySet()
        .stream();
  }

  /**
   * Returns an unmodifiable <u><i>ordered</i></u> map of each {@link Enum}'s value and its associated {@code ID}, with
   * the {@link Map#keySet()} ordered by the {@link Enum#ordinal()}.
   *
   * @return an unmodifiable <u><i>ordered</i></u> map of each {@link Enum}'s value and its associated {@code ID}, with
   *     the {@link Map#keySet()} ordered by the {@link Enum#ordinal()}
   */
  @NotNull
  public Map<E, ID> getOrderedMapIdByEnumValue() {
    return this.orderedMapIdByEnumValue;
  }

  /**
   * Returns the {@code ID} associated with an {@link Enum}'s value.
   *
   * @param enumValue the value upon which to search
   * @return the {@code ID} associated with an {@link Enum}'s value
   */
  @NotNull
  public ID get(@NotNull E enumValue) {
    return getOrderedMapIdByEnumValue().get(enumValue);
  }

  /**
   * Returns an unmodifiable <u><i>ordered</i></u> map of each {@code ID} and it associated {@link Enum}'s value, with
   * the {@link Map#keySet()} ordered by the {@link Enum#ordinal()}.
   *
   * @return an unmodifiable <u><i>ordered</i></u> map of each {@code ID} and it associated {@link Enum}'s value, with
   *     the {@link Map#keySet()} ordered by the {@link Enum#ordinal()}
   */
  @NotNull
  public Map<ID, E> getOrderedMapEnumValueById() {
    return this.orderedMapEnumValueById;
  }

  /**
   * Returns the {@link Enum}'s value associated with an {@code ID}.
   *
   * @param id the value upon which to search
   * @return the {@link Enum}'s value associated with an {@code ID}
   */
  @NotNull
  public Optional<E> get(@NotNull ID id) {
    return Optional.ofNullable(getOrderedMapEnumValueById().get(id));
  }

  /**
   * Returns an unmodifiable unordered map of each search String and its associated {@link Enum}'s value.
   *
   * @return an unmodifiable unordered map of each search String and its associated {@link Enum}'s value
   */
  @NotNull
  public Map<String, E> getEnumValueByNameOrIdOrAltToStringLowerCase() {
    return this.enumValueByNameOrIdOrAltToStringLowerCase;
  }

  /**
   * Returns an {@link Optional} containing a {@link Entry} which contains the {@link Enum}'s value and its associated
   * {@code ID} when the lower case of {@code nameOrIdOrAltToString} is found, otherwise an {@link Entry} containing the
   * first {@link Enum} and its associated {@code ID}.
   *
   * @param nameOrIdOrAltToString the case-insensitive term with which the search is performed
   * @return an {@link Optional} containing a {@link Entry} which contains the {@link Enum}'s value and its associated
   *     {@code ID} when the lower case of {@code nameOrIdOrAltToString} is found, otherwise an {@link Entry} containing
   *     the first {@link Enum} and its associated {@code ID}
   */
  @NotNull
  public Entry<E, ID> valueOfOrDefaultToFirst(
      @NotNull String nameOrIdOrAltToString
  ) {
    return valueOf(
        nameOrIdOrAltToString,
        this.orderedMapIdByEnumValue.entrySet().iterator().next());
  }

  /**
   * Returns an {@link Optional} containing a {@link Entry} which contains the {@link Enum}'s value and its associated
   * {@code ID} when the lower case of {@code nameOrIdOrAltToString} is found, otherwise {@code orElseDefault}.
   *
   * @param nameOrIdOrAltToString the case-insensitive term with which the search is performed
   * @param orElseDefault         the entry to provide if the search returns nothing
   * @return an {@link Optional} containing a {@link Entry} which contains the {@link Enum}'s value and its associated
   *     {@code ID} when the lower case of {@code nameOrIdOrAltToString} is found, otherwise {@code orElseDefault}
   */
  @NotNull
  public Entry<E, ID> valueOf(
      @NotNull String nameOrIdOrAltToString,
      @NotNull Entry<E, ID> orElseDefault
  ) {
    return valueOf(nameOrIdOrAltToString)
        .orElse(orElseDefault);
  }

  /**
   * Returns an {@link Optional} containing a {@link Entry} which contains the {@link Enum}'s value and its associated
   * {@code ID} when the lower case of {@code nameOrIdOrAltToString} is found, otherwise {@link Optional#empty}.
   *
   * @param nameOrIdOrAltToString the case-insensitive term with which the search is performed
   * @return an {@link Optional} containing a {@link Entry} which contains the {@link Enum}'s value and its associated
   *     {@code ID} when the lower case of {@code nameOrIdOrAltToString} is found, otherwise {@link Optional#empty}
   */
  @NotNull
  public Optional<Entry<E, ID>> valueOf(
      @NotNull String nameOrIdOrAltToString
  ) {
    return Optional.ofNullable(getEnumValueByNameOrIdOrAltToStringLowerCase().get(nameOrIdOrAltToString.toLowerCase()))
        .map(enumValue ->
            entry(
                enumValue,
                getOrderedMapIdByEnumValue().get(enumValue)));
  }

  @NotNull
  public String generateJoinDefault(
      @NotNull Entry<E, ID> entry
  ) {
    return "%s(%s)".formatted(
        entry.getKey().name(),
        entry.getValue().toString());
  }

  /**
   * Returns a new {@code String} composed of copies of the {@code Enum name} and {@code ID.toString()} as
   * {@code "ENUM_NAME(ID_TO_STRING)"} for all the enum values, joined together with a copy of the
   * {@link EnumsOps#DEFAULT_SEPARATOR}.
   *
   * @return a new {@code String} composed of copies of the {@code Enum name} and {@code ID.toString()} as *
   *     {@code "ENUM_NAME(ID_TO_STRING)"} for all the enum values, joined together with a copy of the *
   *     {@link EnumsOps#DEFAULT_SEPARATOR}
   */
  @NotNull
  public String join() {
    return join(EnumsOps.DEFAULT_SEPARATOR);
  }

  /**
   * Returns a new {@code String} composed of copies of the {@code Enum name} and {@code ID.toString()} as
   * {@code "ENUM_NAME(ID_TO_STRING)"} for all the enum values, joined together with a copy of the specified
   * {@code separator}.
   *
   * @param separator the string used to separate the enum values
   * @return a new {@code String} composed of copies of the {@code Enum name} and {@code ID.toString()} as
   *     {@code "ENUM_NAME(ID_TO_STRING)"} for all the enum values, joined together with a copy of the specified
   *     {@code separator}
   */
  @NotNull
  public String join(@NotNull String separator) {
    return join(this::generateJoinDefault, separator);
  }

  /**
   * Returns a new {@code String} composed of copies of the {@code Enum} and {@code ID} transformed by the
   * {@code eAndIdToString} function for all the enum values, and joined together with a copy of the
   * {@link EnumsOps#DEFAULT_SEPARATOR}.
   *
   * @param eAndIdToString the function to transform an enum value into a String
   * @return a new {@code String} composed of copies of the {@code Enum} and {@code ID} transformed by the
   *     {@code eAndIdToString} function for all the enum values, and joined together with a copy of the
   *     {@link EnumsOps#DEFAULT_SEPARATOR}
   */
  @NotNull
  public String join(
      @NotNull Function<Entry<E, ID>, String> eAndIdToString
  ) {
    return join(eAndIdToString, EnumsOps.DEFAULT_SEPARATOR);
  }

  /**
   * Returns a new {@code String} composed of copies of the {@code Enum} and {@code ID} transformed by the
   * {@code eAndIdToString} function for all the enum values, and joined together with a copy of the specified
   * {@code separator}.
   *
   * @param eAndIdToString the function to transform an enum value into a String
   * @param separator      the string used to separate the enum values
   * @return a new {@code String} composed of copies of the {@code Enum} and {@code ID} transformed by the
   *     {@code eAndIdToString} function for all the enum values, and joined together with a copy of the specified
   *     {@code separator}
   */
  @NotNull
  public String join(
      @NotNull Function<Entry<E, ID>, String> eAndIdToString,
      @NotNull String separator
  ) {
    return join(getEnumsOps().stream(), eAndIdToString, separator);
  }

  /**
   * Returns a new {@code String} composed of copies of the {@code Enum} and {@code ID} as
   * {@code "ENUM_NAME(ID_TO_STRING)"} for each of the provided {@link Enum} values, joined together with a copy of the
   * {@link EnumsOps#DEFAULT_SEPARATOR}.
   *
   * @param es the list of enum values to use
   * @return a new {@code String} composed of copies of the {@code Enum} and {@code ID} as
   *     {@code "ENUM_NAME(ID_TO_STRING)"} for each of the provided {@link Enum} values, joined together with a copy of
   *     the {@link EnumsOps#DEFAULT_SEPARATOR}
   */
  @NotNull
  public String join(@NotNull Stream<E> es) {
    return join(es, this::generateJoinDefault);
  }

  /**
   * Returns a new {@code String} composed of copies of the {@code Enum} and {@code ID} transformed by the
   * {@code eAndIdToString} function for each of the provided {@link Enum} values, and joined together with a copy of
   * the {@link EnumsOps#DEFAULT_SEPARATOR}.
   *
   * @param es             the list of enum values to use
   * @param eAndIdToString the function to transform an enum value into a String
   * @return a new {@code String} composed of copies of the {@code Enum} and {@code ID} transformed by the
   *     {@code eAndIdToString} function for each of the provided {@link Enum} values, and joined together with a copy
   *     of the {@link EnumsOps#DEFAULT_SEPARATOR}
   */
  @NotNull
  public String join(
      @NotNull Stream<E> es,
      @NotNull Function<Entry<E, ID>, String> eAndIdToString
  ) {
    return join(es, eAndIdToString, EnumsOps.DEFAULT_SEPARATOR);
  }

  /**
   * Returns a new {@code String} composed of copies of the {@code Enum} and {@code ID} as
   * {@code "ENUM_NAME(ID_TO_STRING)"} for each of the provided {@link Enum} values, joined together with a copy of the
   * specified {@code separator}.
   *
   * @param es        the list of enum values to use
   * @param separator the string used to separate the enum values
   * @return a new {@code String} composed of copies of the {@code Enum} and {@code ID} as
   *     {@code "ENUM_NAME(ID_TO_STRING)"} for each of the provided {@link Enum} values, joined together with a copy of
   *     the specified {@code separator}
   */
  @NotNull
  public String join(
      @NotNull Stream<E> es,
      @NotNull String separator
  ) {
    return join(es, this::generateJoinDefault, separator);
  }

  /**
   * Returns a new {@code String} composed of copies of the provided {@code Enum}s and their associated {@code ID}s
   * transformed by the {@code eAndIdToString} function, and joined together with a copy of the specified
   * {@code separator}.
   *
   * @param es             the list of enum values to use
   * @param eAndIdToString the function to transform an enum and its associated id value into a String
   * @param separator      the string used to separate the enum values
   * @return a new {@code String} composed of copies of the provided {@code Enum}s and their associated {@code ID}s
   *     transformed by the {@code eAndIdToString} function, and joined together with a copy of the specified
   *     {@code separator}
   */
  @NotNull
  public String join(
      @NotNull Stream<E> es,
      @NotNull Function<Entry<E, ID>, String> eAndIdToString,
      @NotNull String separator
  ) {
    return String.join(
        separator,
        es.map(e ->
                eAndIdToString.apply(entry(e, getOrderedMapIdByEnumValue().get(e))))
            .toList());
  }

  /**
   * Returns a new {@code String} composed of copies of the {@code Enum name} and {@code ID.toString()} as
   * {@code "ENUM_NAME(ID_TO_STRING)"} for all the id values, joined together with a copy of the
   * {@link EnumsOps#DEFAULT_SEPARATOR}.
   *
   * @return a new {@code String} composed of copies of the {@code Enum name} and {@code ID.toString()} as
   *     {@code "ENUM_NAME(ID_TO_STRING)"} for all the id values, joined together with a copy of the
   *     {@link EnumsOps#DEFAULT_SEPARATOR}
   */
  @NotNull
  public String joinOnIds() {
    return joinOnIds(EnumsOps.DEFAULT_SEPARATOR);
  }

  /**
   * Returns a new {@code String} composed of copies of the {@code Enum name} and {@code ID.toString()} as
   * {@code "ENUM_NAME(ID_TO_STRING)"} for all the id values, joined together with a copy of the specified
   * {@code separator}.
   *
   * @param separator the string used to separate the enum values
   * @return a new {@code String} composed of copies of the {@code Enum name} and {@code ID.toString()} as
   *     {@code "ENUM_NAME(ID_TO_STRING)"} for all the id values, joined together with a copy of the specified
   *     {@code separator}
   */
  @NotNull
  public String joinOnIds(@NotNull String separator) {
    return joinOnIds(this::generateJoinDefault, separator);
  }

  /**
   * Returns a new {@code String} composed of copies of the {@code Enum} and {@code ID} transformed by the
   * {@code eAndIdToString} function for all the id values, and joined together with a copy of the
   * {@link EnumsOps#DEFAULT_SEPARATOR}.
   *
   * @param eAndIdToString the function to transform an enum value into a String
   * @return a new {@code String} composed of copies of the {@code Enum} and {@code ID} transformed by the
   *     {@code eAndIdToString} function for all the id values, and joined together with a copy of the
   *     {@link EnumsOps#DEFAULT_SEPARATOR}
   */
  @NotNull
  public String joinOnIds(
      @NotNull Function<Entry<E, ID>, String> eAndIdToString
  ) {
    return joinOnIds(eAndIdToString, EnumsOps.DEFAULT_SEPARATOR);
  }

  /**
   * Returns a new {@code String} composed of copies of the {@code Enum} and {@code ID} transformed by the
   * {@code eAndIdToString} function for all the id values, and joined together with a copy of the specified
   * {@code separator}.
   *
   * @param eAndIdToString the function to transform an enum value into a String
   * @param separator      the string used to separate the enum values
   * @return a new {@code String} composed of copies of the {@code Enum} and {@code ID} transformed by the
   *     {@code eAndIdToString} function for all the id values, and joined together with a copy of the specified
   *     {@code separator}
   */
  @NotNull
  public String joinOnIds(
      @NotNull Function<Entry<E, ID>, String> eAndIdToString,
      @NotNull String separator
  ) {
    return joinOnIds(getOrderedMapEnumValueById().keySet().stream(), eAndIdToString, separator);
  }

  /**
   * Returns a new {@code String} composed of copies of the {@code Enum} and {@code ID} as
   * {@code "ENUM_NAME(ID_TO_STRING)"} for each of the provided {@code ID} values, joined together with a copy of the
   * {@link EnumsOps#DEFAULT_SEPARATOR}.
   *
   * @param ids the list of id values to use
   * @return a new {@code String} composed of copies of the {@code Enum} and {@code ID} as
   *     {@code "ENUM_NAME(ID_TO_STRING)"} for each of the provided {@code ID} values, joined together with a copy of
   *     the {@link EnumsOps#DEFAULT_SEPARATOR}
   */
  @NotNull
  public String joinOnIds(@NotNull Stream<ID> ids) {
    return joinOnIds(ids, this::generateJoinDefault);
  }

  /**
   * Returns a new {@code String} composed of copies of the {@code Enum} and {@code ID} transformed by the
   * {@code eAndIdToString} function for each of the provided {@code ID} values, and joined together with a copy of the
   * {@link EnumsOps#DEFAULT_SEPARATOR}.
   *
   * @param ids            the list of id values to use
   * @param eAndIdToString the function to transform an enum value into a String
   * @return a new {@code String} composed of copies of the {@code Enum} and {@code ID} transformed by the
   *     {@code eAndIdToString} function for each of the provided {@code ID} values, and joined together with a copy of
   *     the {@link EnumsOps#DEFAULT_SEPARATOR}
   */
  @NotNull
  public String joinOnIds(
      @NotNull Stream<ID> ids,
      @NotNull Function<Entry<E, ID>, String> eAndIdToString
  ) {
    return joinOnIds(ids, eAndIdToString, EnumsOps.DEFAULT_SEPARATOR);
  }

  /**
   * Returns a new {@code String} composed of copies of the {@code Enum} and {@code ID} as
   * {@code "ENUM_NAME(ID_TO_STRING)"} for each of the provided {@code ID} values, joined together with a copy of the
   * specified {@code separator}.
   *
   * @param ids       the list of id values to use
   * @param separator the string used to separate the enum values
   * @return a new {@code String} composed of copies of the {@code Enum} and {@code ID} as
   *     {@code "ENUM_NAME(ID_TO_STRING)"} for each of the provided {@code ID} values, joined together with a copy of
   *     the specified {@code separator}
   */
  @NotNull
  public String joinOnIds(
      @NotNull Stream<ID> ids,
      @NotNull String separator
  ) {
    return joinOnIds(ids, this::generateJoinDefault, separator);
  }

  /**
   * Returns a new {@code String} composed of copies of the {@code Enum} and {@code ID} transformed by the
   * {@code eAndIdToString} function for each of the provided {@code ID} values, and joined together with a copy of the
   * specified {@code separator}.
   *
   * @param ids            the list of enum values to use
   * @param eAndIdToString the function to transform an enum and its associated id value into a String
   * @param separator      the string used to separate the enum values
   * @return a new {@code String} composed of copies of the {@code Enum} and {@code ID} transformed by the
   *     {@code eAndIdToString} function for each of the provided {@code ID} values, and joined together with a copy of
   *     the specified {@code separator}
   */
  @NotNull
  public String joinOnIds(
      @NotNull Stream<ID> ids,
      @NotNull Function<Entry<E, ID>, String> eAndIdToString,
      @NotNull String separator
  ) {
    return String.join(
        separator,
        ids.map(id ->
                eAndIdToString.apply(entry(getOrderedMapEnumValueById().get(id), id)))
            .toList());
  }
}
